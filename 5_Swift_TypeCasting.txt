// 타입캐스팅

## 타입 캐스팅

- 인스턴스 타입을 검사 - is 연산자 / 클래스 계층 상의 타입 변환 - as 연산자
- 기본적으로 데이터(저장 속성)를 추가하는 관점에서 생각

## is 연산자

- 타입에 대한 검사를 수행하는 연산자

### 인스턴스 is 타입   (이항연산자)

- 참이면 true 리턴
- 거짓이면 false 리턴
- 상속관계의 계층에서 포함관계를 생각해보면 쉬움

let person2 = Person()
let student2 = Student()
let undergraduate2 = Undergraduate()


let people = [person1, person2, student1, student2, undergraduate1, undergraduate2]


// 학생 인스턴스의 갯수를 세고 싶다.

var studentNumber = 0

for someOne in people {
    if someOne is Student {
        studentNumber += 1
    }
}

## as 연산자 (type cast operator)

- 인스턴스 타입의 (메모리구조에 대한) 힌트를 변경하는 - as 연산자

1. Upcasting (업캐스팅)
    - 인스턴스 as 타입
    - 하위클래스의 메모리구조로 저장된 인스턴스를 상위클래스 타입으로 인식

2. Downcasting (다운캐스팅) (실패가능성이 있음)
    - 인스턴스 as? 타입 / 인스턴스 as! 타입
    
    ### as? 연산자
    
    - 참이면 반환타입은 Optional타입
    - 실패시 nil 반환
    
    ### as! 연산자
    
    - 참이면 반화타입은 Optional타입의 값을 강제 언래핑한 타입
    - 실패시 런타임 오류


    let ppp = person as? Undergraduate  // Undergraduate? 타입



if let newPerson = person as? Undergraduate {   // if let 바인딩과 함께 사용 (옵셔널 언래핑)
    newPerson.major
    print(newPerson.major)
}

let person3: Undergraduate = person as! Undergraduate
person3.major


업캐스팅
let undergraduate2: Undergraduate = Undergraduate()
undergraduate2.id
undergraduate2.name
undergraduate2.studentId
undergraduate2.major
//undergraduate2.name = "길동"




let person4 = undergraduate2 as Person       // 항상 성공 (컴파일러가 항상 성공할 수 밖에 없다는 것을 알고 있음)
person4.id
person4.name
//person4.studentId
//person4.major